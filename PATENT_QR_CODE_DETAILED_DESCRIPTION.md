# PROVISIONAL PATENT APPLICATION
## Dynamic QR Code Memorial Upload System - Detailed Description

---

### DETAILED DESCRIPTION OF THE INVENTION

The following detailed description, taken in conjunction with the accompanying drawings, provides a comprehensive explanation of the dynamic QR code memorial upload system according to the present invention.

---

## SYSTEM ARCHITECTURE

### QR Code Data Structure

Each QR code generated by the system encodes a URL with the following structure:

```
https://[DOMAIN]/m/[MEMORIAL_ID]?source=[SOURCE]&action=[ACTION]

Components:
- DOMAIN: Memorial platform domain (e.g., opictuary.com)
- MEMORIAL_ID: Unique identifier for memorial (alphanumeric, 6-12 characters)
- SOURCE: Optional parameter indicating physical artifact type
- ACTION: Optional parameter indicating suggested user action
```

**Example QR Code URLs:**

```
Tombstone Plaque:
https://opictuary.com/m/abc123?source=tombstone

Memorial Card:
https://opictuary.com/m/xyz789?source=memorial_card

Funeral Program:
https://opictuary.com/m/def456?source=funeral_program

General Upload:
https://opictuary.com/m/ghi101?action=upload

Tombstone Photo Upload:
https://opictuary.com/m/jkl202?source=tombstone&action=tombstone_photo
```

### QR Code Generation Process

**Step 1: Memorial Creation**
When a memorial is created on the platform, the system automatically generates a unique memorial ID.

```typescript
function createMemorial(deceasedName: string, ownerUserId: string): Memorial {
  // Generate unique 8-character alphanumeric ID
  const memorialId = generateUniqueId(8); // e.g., "a7x9m2k4"
  
  const memorial = {
    id: memorialId,
    deceased_name: deceasedName,
    owner_user_id: ownerUserId,
    created_at: new Date(),
    qr_code_generated: false
  };
  
  // Save to database
  database.memorials.insert(memorial);
  
  return memorial;
}
```

**Step 2: QR Code URL Construction**
The memorial owner requests QR code generation for specific physical products:

```typescript
function generateQRCodeURL(
  memorialId: string,
  source: 'tombstone' | 'memorial_card' | 'funeral_program' | 'general',
  action?: 'upload' | 'view' | 'tombstone_photo'
): string {
  const baseUrl = 'https://opictuary.com/m';
  let url = `${baseUrl}/${memorialId}`;
  
  const params = new URLSearchParams();
  if (source) params.append('source', source);
  if (action) params.append('action', action);
  
  if (params.toString()) {
    url += `?${params.toString()}`;
  }
  
  return url;
}

// Examples:
generateQRCodeURL('abc123', 'tombstone')
// Returns: "https://opictuary.com/m/abc123?source=tombstone"

generateQRCodeURL('abc123', 'memorial_card', 'upload')
// Returns: "https://opictuary.com/m/abc123?source=memorial_card&action=upload"
```

**Step 3: QR Code Image Generation**
The URL is converted to a QR code image using standard QR encoding:

```typescript
import QRCode from 'qrcode';

async function generateQRCodeImage(
  url: string,
  size: number = 500,
  errorCorrectionLevel: 'L' | 'M' | 'Q' | 'H' = 'H'
): Promise<Buffer> {
  // Generate QR code with high error correction for durability
  const qrCodeBuffer = await QRCode.toBuffer(url, {
    errorCorrectionLevel, // 'H' = 30% error correction
    type: 'png',
    quality: 1,
    margin: 1,
    width: size,
    color: {
      dark: '#000000',  // Black modules
      light: '#FFFFFF'  // White background
    }
  });
  
  return qrCodeBuffer;
}
```

**Error Correction Levels:**
- **L (Low)**: 7% damage recovery - used for digital displays
- **M (Medium)**: 15% damage recovery - used for indoor print
- **Q (Quartile)**: 25% damage recovery - used for memorial cards
- **H (High)**: 30% damage recovery - used for tombstone plaques (outdoor exposure)

**Step 4: Physical Product Integration**

**For Tombstone Plaques:**
```typescript
async function generateTombstonePlaque(memorialId: string) {
  const url = generateQRCodeURL(memorialId, 'tombstone');
  
  // Large QR code for distance scanning (3 feet away)
  const qrImage = await generateQRCodeImage(url, 800, 'H');
  
  // Create plaque design with QR code
  const plaque = {
    qr_code_image: qrImage,
    memorial_id: memorialId,
    size: '3x3 inches',
    material: 'anodized_aluminum',
    mounting: 'adhesive_backing',
    url_encoded: url,
    instructions: 'Scan to view memorial and share photos'
  };
  
  // Send to print fulfillment service
  await sendToPrintService(plaque);
  
  return plaque;
}
```

**For Memorial Cards:**
```typescript
async function generateMemorialCards(
  memorialId: string,
  quantity: number,
  cardDesign: CardDesign
) {
  const url = generateQRCodeURL(memorialId, 'memorial_card');
  
  // Smaller QR code for close-range scanning (6-12 inches)
  const qrImage = await generateQRCodeImage(url, 300, 'Q');
  
  const cardBatch = {
    memorial_id: memorialId,
    quantity: quantity,
    qr_code_image: qrImage,
    front_design: cardDesign.front, // Photo, name, dates, prayer
    back_design: {
      qr_code: qrImage,
      qr_size: '0.75x0.75 inches',
      text: 'Scan to view memorial & share photos',
      layout: cardDesign.back_layout
    },
    card_size: '2x3.5 inches',
    cardstock: '16pt',
    coating: 'UV_gloss'
  };
  
  // Send to card printing service
  await sendToCardPrinter(cardBatch);
  
  return cardBatch;
}
```

---

## QR CODE SCAN HANDLING

### Scan Detection and Routing

When a user scans any QR code, their device opens the encoded URL in the default browser or QR scanner app. The memorial platform's web server receives the request and processes it:

```typescript
// Server-side request handler
app.get('/m/:memorialId', async (req, res) => {
  const memorialId = req.params.memorialId;
  const source = req.query.source as string | undefined;
  const action = req.query.action as string | undefined;
  
  // Retrieve memorial from database
  const memorial = await database.memorials.findById(memorialId);
  
  if (!memorial) {
    return res.status(404).send('Memorial not found');
  }
  
  // Log QR scan event
  await logQRScan({
    memorial_id: memorialId,
    source: source || 'unknown',
    action: action || 'default',
    user_agent: req.headers['user-agent'],
    ip_address: req.ip,
    timestamp: new Date()
  });
  
  // Determine user flow based on source and action
  const flow = determineUserFlow(source, action, req.headers['user-agent']);
  
  // Render appropriate page
  return renderMemorialPage(res, memorial, flow);
});
```

### Context-Aware Flow Determination

The system analyzes the request to determine the optimal user experience:

```typescript
function determineUserFlow(
  source?: string,
  action?: string,
  userAgent?: string
): UserFlow {
  
  // Explicit action takes precedence
  if (action === 'tombstone_photo') {
    return 'TOMBSTONE_UPLOAD';
  }
  if (action === 'upload') {
    return 'GENERAL_UPLOAD';
  }
  if (action === 'view') {
    return 'VIEW_MEMORIAL';
  }
  
  // Source-based defaults
  if (source === 'tombstone') {
    // Tombstone scans default to offering tombstone photo upload
    return 'TOMBSTONE_PROMPT';
  }
  
  if (source === 'memorial_card' || source === 'funeral_program') {
    // Card/program scans default to showing action menu
    return 'ACTION_MENU';
  }
  
  // Mobile devices get upload-friendly interface
  if (isMobileDevice(userAgent)) {
    return 'ACTION_MENU';
  }
  
  // Desktop defaults to viewing memorial
  return 'VIEW_MEMORIAL';
}

function isMobileDevice(userAgent?: string): boolean {
  if (!userAgent) return false;
  return /iPhone|iPad|iPod|Android/i.test(userAgent);
}
```

---

## USER INTERFACE FLOWS

### Flow 1: Tombstone Scan ‚Üí Tombstone Photo Upload

**Page Rendered:**
```html
<!DOCTYPE html>
<html>
<head>
  <title>John Smith Memorial - Upload Tombstone Photo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
  <div class="container">
    <h1>Welcome to John Smith's Memorial</h1>
    <p>March 15, 1950 - August 2, 2024</p>
    
    <div class="action-prompt">
      <h2>üì∑ Would you like to upload a photo of the tombstone?</h2>
      <p>Help document how the grave looks today. Photos are reviewed by family before publishing.</p>
      
      <button onclick="openCamera()" class="btn-primary">
        Take Tombstone Photo Now
      </button>
      
      <button onclick="selectFromLibrary()" class="btn-secondary">
        Choose Photo from Library
      </button>
      
      <a href="/m/abc123?action=view" class="link">
        Skip and view memorial page instead
      </a>
    </div>
  </div>
  
  <script>
    function openCamera() {
      // Open native camera for immediate photo
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.capture = 'environment'; // Use rear camera
      input.onchange = handlePhotoSelection;
      input.click();
    }
    
    function selectFromLibrary() {
      // Open photo library
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.multiple = false;
      input.onchange = handlePhotoSelection;
      input.click();
    }
    
    function handlePhotoSelection(event) {
      const file = event.target.files[0];
      if (file) {
        // Proceed to upload form
        window.location.href = `/m/abc123/upload/tombstone?file=${file.name}`;
      }
    }
  </script>
</body>
</html>
```

**Upload Form:**
After photo selection, user sees:
```html
<div class="upload-form">
  <h2>Upload Tombstone Photo</h2>
  
  <div class="photo-preview">
    <img src="[preview]" alt="Tombstone photo preview" />
  </div>
  
  <form id="tombstone-upload-form">
    <label>Your Name (optional)</label>
    <input type="text" name="uploader_name" placeholder="Anonymous" />
    
    <label>Your Relationship (optional)</label>
    <select name="relationship">
      <option value="">Select...</option>
      <option value="family">Family Member</option>
      <option value="friend">Friend</option>
      <option value="visitor">Cemetery Visitor</option>
      <option value="descendant">Descendant</option>
    </select>
    
    <label>Photo Date</label>
    <input type="date" name="photo_date" value="[today]" />
    
    <label>Notes (optional)</label>
    <textarea name="notes" placeholder="Add any details about the photo..."></textarea>
    
    <button type="submit" class="btn-primary">
      Upload Photo
    </button>
  </form>
  
  <div class="privacy-note">
    ‚ÑπÔ∏è Photos are reviewed by family before publishing to the memorial page.
  </div>
</div>
```

### Flow 2: Memorial Card Scan ‚Üí Action Menu

**Action Menu Interface:**
```html
<div class="action-menu">
  <h1>John Smith Memorial</h1>
  <p>March 15, 1950 - August 2, 2024</p>
  
  <p class="subtitle">What would you like to do?</p>
  
  <div class="action-cards">
    <a href="/m/abc123?action=view" class="action-card">
      <div class="icon">üëÅÔ∏è</div>
      <h3>View Memorial Page</h3>
      <p>See photos, videos, and tributes</p>
    </a>
    
    <a href="/m/abc123/upload" class="action-card">
      <div class="icon">üì∑</div>
      <h3>Upload Photos/Videos</h3>
      <p>Share your memories</p>
    </a>
    
    <a href="/m/abc123/tribute" class="action-card">
      <div class="icon">‚úçÔ∏è</div>
      <h3>Write Tribute</h3>
      <p>Share your thoughts and condolences</p>
    </a>
    
    <a href="/m/abc123/donate" class="action-card">
      <div class="icon">üíù</div>
      <h3>Send Flowers</h3>
      <p>Support the family</p>
    </a>
  </div>
</div>
```

### Flow 3: General Photo/Video Upload

**Multi-File Upload Interface:**
```html
<div class="general-upload">
  <h1>Upload Photos & Videos</h1>
  <p>John Smith Memorial (1950-2024)</p>
  
  <div class="upload-dropzone" id="dropzone">
    <div class="dropzone-content">
      <div class="icon">üìÅ</div>
      <h3>Drop files here or click to browse</h3>
      <p>Upload photos and videos from your device</p>
      <button class="btn-primary">Choose Files</button>
    </div>
  </div>
  
  <div class="selected-files" id="selected-files">
    <!-- Dynamically populated with selected files -->
  </div>
  
  <form id="upload-form">
    <h3>About Your Upload</h3>
    
    <label>Your Name (optional)</label>
    <input type="text" name="uploader_name" placeholder="Anonymous" />
    
    <label>Your Relationship</label>
    <select name="relationship">
      <option value="family">Family Member</option>
      <option value="friend">Friend</option>
      <option value="colleague">Colleague/Coworker</option>
      <option value="neighbor">Neighbor</option>
      <option value="other">Other</option>
    </select>
    
    <label>Description (optional)</label>
    <textarea 
      name="description" 
      placeholder="Tell us about these photos/videos...&#10;Example: Family reunion 2015, vacation in Hawaii, college graduation"
    ></textarea>
    
    <button type="submit" class="btn-primary">
      Upload <span id="file-count">0</span> Files
    </button>
  </form>
  
  <div class="upload-progress" id="progress" style="display: none;">
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
    <p class="progress-text" id="progress-text">Uploading... 0%</p>
  </div>
</div>

<script>
  // Drag and drop functionality
  const dropzone = document.getElementById('dropzone');
  
  dropzone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropzone.classList.add('dragover');
  });
  
  dropzone.addEventListener('dragleave', () => {
    dropzone.classList.remove('dragover');
  });
  
  dropzone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
    const files = e.dataTransfer.files;
    handleFiles(files);
  });
  
  // File selection
  dropzone.querySelector('button').addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*,video/*';
    input.multiple = true;
    input.onchange = (e) => handleFiles(e.target.files);
    input.click();
  });
  
  let selectedFiles = [];
  
  function handleFiles(files) {
    selectedFiles = Array.from(files);
    displaySelectedFiles();
    updateFileCount();
  }
  
  function displaySelectedFiles() {
    const container = document.getElementById('selected-files');
    container.innerHTML = '';
    
    selectedFiles.forEach((file, index) => {
      const fileCard = document.createElement('div');
      fileCard.className = 'file-card';
      
      const isVideo = file.type.startsWith('video/');
      const icon = isVideo ? 'üé¨' : 'üì∑';
      const size = formatFileSize(file.size);
      
      fileCard.innerHTML = `
        <div class="file-icon">${icon}</div>
        <div class="file-info">
          <div class="file-name">${file.name}</div>
          <div class="file-size">${size}</div>
        </div>
        <button class="file-remove" onclick="removeFile(${index})">‚úï</button>
      `;
      
      container.appendChild(fileCard);
    });
  }
  
  function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }
  
  function updateFileCount() {
    document.getElementById('file-count').textContent = selectedFiles.length;
  }
  
  function removeFile(index) {
    selectedFiles.splice(index, 1);
    displaySelectedFiles();
    updateFileCount();
  }
</script>
```

---

## FILE UPLOAD PROCESSING

### Client-Side Upload with Progress Tracking

```typescript
async function uploadFiles(
  files: File[],
  memorialId: string,
  uploadType: 'tombstone' | 'general',
  metadata: UploadMetadata
) {
  const progressElement = document.getElementById('progress');
  const progressFill = document.getElementById('progress-fill');
  const progressText = document.getElementById('progress-text');
  
  progressElement.style.display = 'block';
  
  // Upload files sequentially with progress
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('memorial_id', memorialId);
    formData.append('upload_type', uploadType);
    formData.append('uploader_name', metadata.uploader_name || 'Anonymous');
    formData.append('relationship', metadata.relationship);
    formData.append('description', metadata.description || '');
    
    try {
      const response = await fetch('/api/memorial/upload', {
        method: 'POST',
        body: formData,
        // Track upload progress
        onUploadProgress: (progressEvent) => {
          const fileProgress = (i / files.length) * 100;
          const currentFileProgress = (progressEvent.loaded / progressEvent.total) * (100 / files.length);
          const totalProgress = fileProgress + currentFileProgress;
          
          progressFill.style.width = totalProgress + '%';
          progressText.textContent = `Uploading... ${Math.round(totalProgress)}%`;
        }
      });
      
      if (!response.ok) {
        throw new Error(`Upload failed for ${file.name}`);
      }
      
    } catch (error) {
      console.error(`Error uploading ${file.name}:`, error);
      alert(`Failed to upload ${file.name}. Please try again.`);
      return;
    }
  }
  
  // Upload complete
  progressFill.style.width = '100%';
  progressText.textContent = 'Upload complete!';
  
  // Show success message
  showSuccessMessage(files.length);
}

function showSuccessMessage(fileCount: number) {
  const successHTML = `
    <div class="success-message">
      <div class="success-icon">‚úì</div>
      <h2>Upload Successful!</h2>
      <p>
        Thank you for sharing ${fileCount} ${fileCount === 1 ? 'file' : 'files'}. 
        Your photos/videos will appear on the memorial page after family review.
      </p>
      <p>
        The memorial owner will be notified and can approve your contribution.
      </p>
      <div class="success-actions">
        <a href="/m/abc123?action=view" class="btn-primary">View Memorial Page</a>
        <button onclick="uploadMore()" class="btn-secondary">Upload More Files</button>
      </div>
    </div>
  `;
  
  document.querySelector('.general-upload').innerHTML = successHTML;
}
```

### Server-Side Upload Processing

```typescript
// Server endpoint for file uploads
app.post('/api/memorial/upload', upload.single('file'), async (req, res) => {
  const file = req.file;
  const memorialId = req.body.memorial_id;
  const uploadType = req.body.upload_type;
  const uploaderName = req.body.uploader_name;
  const relationship = req.body.relationship;
  const description = req.body.description;
  
  // Validate memorial exists
  const memorial = await database.memorials.findById(memorialId);
  if (!memorial) {
    return res.status(404).json({ error: 'Memorial not found' });
  }
  
  // Validate file type
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4', 'video/quicktime'];
  if (!allowedTypes.includes(file.mimetype)) {
    return res.status(400).json({ error: 'Invalid file type' });
  }
  
  // Validate file size (photos: 50MB, videos: 500MB)
  const maxSize = file.mimetype.startsWith('video/') ? 500 * 1024 * 1024 : 50 * 1024 * 1024;
  if (file.size > maxSize) {
    return res.status(400).json({ error: 'File too large' });
  }
  
  // Upload to cloud storage (S3, Google Cloud Storage, etc.)
  const cloudUrl = await uploadToCloud(file);
  
  // Run content moderation
  const moderationResult = await moderateContent(file, description);
  
  // Create upload record in moderation queue
  const upload = await database.memorial_uploads.create({
    memorial_id: memorialId,
    file_url: cloudUrl,
    file_type: file.mimetype,
    file_size: file.size,
    upload_type: uploadType,
    uploader_name: uploaderName,
    relationship: relationship,
    description: description,
    moderation_status: moderationResult.autoApprove ? 'approved' : 'pending',
    moderation_flags: moderationResult.flags,
    uploaded_at: new Date()
  });
  
  // Notify memorial owner of new upload
  await notifyMemorialOwner(memorial, upload);
  
  res.json({
    success: true,
    upload_id: upload.id,
    status: upload.moderation_status
  });
});
```

---

## CONTENT MODERATION SYSTEM

### Automated Content Filtering

```typescript
async function moderateContent(
  file: Express.Multer.File,
  description: string
): Promise<ModerationResult> {
  const flags: string[] = [];
  let autoApprove = true;
  
  // 1. Check description for profanity
  if (containsProfanity(description)) {
    flags.push('Description contains profanity');
    autoApprove = false;
  }
  
  // 2. Image analysis (for photos)
  if (file.mimetype.startsWith('image/')) {
    const imageAnalysis = await analyzeImage(file.buffer);
    
    if (imageAnalysis.inappropriateContent > 0.7) {
      flags.push('Potentially inappropriate content detected');
      autoApprove = false;
    }
    
    if (imageAnalysis.violence > 0.6) {
      flags.push('Violent content detected');
      autoApprove = false;
    }
  }
  
  // 3. Video analysis (for videos)
  if (file.mimetype.startsWith('video/')) {
    const videoAnalysis = await analyzeVideo(file.path);
    
    if (videoAnalysis.inappropriateAudio > 0.6) {
      flags.push('Inappropriate audio detected');
      autoApprove = false;
    }
  }
  
  // 4. File metadata check
  if (file.size === 0) {
    flags.push('Empty file');
    autoApprove = false;
  }
  
  return {
    autoApprove,
    flags,
    confidence: flags.length === 0 ? 1.0 : 0.5
  };
}

function containsProfanity(text: string): boolean {
  const profanityList = loadProfanityList();
  const normalizedText = text.toLowerCase();
  
  return profanityList.some(word => normalizedText.includes(word));
}
```

### Family Moderation Interface

```typescript
// Memorial owner dashboard - pending uploads
app.get('/memorial/:id/moderation', async (req, res) => {
  const memorialId = req.params.id;
  const ownerId = req.session.userId;
  
  // Verify ownership
  const memorial = await database.memorials.findById(memorialId);
  if (memorial.owner_user_id !== ownerId) {
    return res.status(403).send('Unauthorized');
  }
  
  // Get pending uploads
  const pendingUploads = await database.memorial_uploads.findAll({
    where: {
      memorial_id: memorialId,
      moderation_status: 'pending'
    },
    order: [['uploaded_at', 'DESC']]
  });
  
  res.render('moderation-dashboard', {
    memorial,
    pendingUploads
  });
});
```

**Moderation Dashboard UI:**
```html
<div class="moderation-dashboard">
  <h1>Review Pending Uploads</h1>
  <p>John Smith Memorial - ${pendingUploads.length} items awaiting review</p>
  
  <div class="pending-uploads">
    <!-- For each upload -->
    <div class="upload-card">
      <div class="upload-preview">
        <img src="${upload.file_url}" alt="Upload preview" />
      </div>
      
      <div class="upload-details">
        <h3>Tombstone Photo</h3>
        <p class="uploader">Uploaded by: Jennifer (cousin)</p>
        <p class="date">November 10, 2024, 2:34 PM</p>
        <p class="description">"Visited the grave today. Looks beautiful."</p>
        
        ${upload.moderation_flags.length > 0 ? `
          <div class="flags">
            ‚ö†Ô∏è Flagged: ${upload.moderation_flags.join(', ')}
          </div>
        ` : ''}
      </div>
      
      <div class="upload-actions">
        <button onclick="approveUpload('${upload.id}')" class="btn-approve">
          ‚úì Approve
        </button>
        <button onclick="rejectUpload('${upload.id}')" class="btn-reject">
          ‚úï Reject
        </button>
        <button onclick="editUpload('${upload.id}')" class="btn-edit">
          ‚úèÔ∏è Edit Details
        </button>
      </div>
    </div>
  </div>
  
  <div class="bulk-actions">
    <button onclick="approveAll()" class="btn-secondary">
      Approve All (${pendingUploads.length})
    </button>
  </div>
</div>
```

---

## QR CODE TRACKING AND ANALYTICS

### Scan Event Logging

```typescript
interface QRScanEvent {
  id: string;
  memorial_id: string;
  source: string;
  action: string;
  user_agent: string;
  ip_address: string;
  geo_location?: { lat: number; lon: number };
  timestamp: Date;
  resulted_in_upload: boolean;
  upload_id?: string;
}

async function logQRScan(event: Omit<QRScanEvent, 'id'>): Promise<void> {
  await database.qr_scans.create({
    id: generateUUID(),
    ...event,
    resulted_in_upload: false // Updated later if upload occurs
  });
}

// Update scan record when upload completes
async function linkUploadToScan(uploadId: string, memorialId: string): Promise<void> {
  // Find most recent scan from same user within last 10 minutes
  const recentScan = await database.qr_scans.findOne({
    where: {
      memorial_id: memorialId,
      timestamp: {
        $gte: new Date(Date.now() - 10 * 60 * 1000) // Last 10 minutes
      }
    },
    order: [['timestamp', 'DESC']]
  });
  
  if (recentScan) {
    await database.qr_scans.update(
      { 
        resulted_in_upload: true,
        upload_id: uploadId
      },
      { where: { id: recentScan.id } }
    );
  }
}
```

### Analytics Dashboard

```typescript
// Generate analytics for memorial owner
async function generateQRAnalytics(
  memorialId: string,
  startDate: Date,
  endDate: Date
): Promise<QRAnalytics> {
  const scans = await database.qr_scans.findAll({
    where: {
      memorial_id: memorialId,
      timestamp: {
        $between: [startDate, endDate]
      }
    }
  });
  
  // Group by source
  const bySource = scans.reduce((acc, scan) => {
    acc[scan.source] = (acc[scan.source] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  // Calculate conversion rate
  const uploadsFromScans = scans.filter(s => s.resulted_in_upload).length;
  const conversionRate = scans.length > 0 ? (uploadsFromScans / scans.length) * 100 : 0;
  
  // Most active days
  const scansByDay = scans.reduce((acc, scan) => {
    const day = scan.timestamp.toISOString().split('T')[0];
    acc[day] = (acc[day] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  const mostActiveDay = Object.entries(scansByDay)
    .sort((a, b) => b[1] - a[1])[0];
  
  return {
    total_scans: scans.length,
    scans_by_source: bySource,
    uploads_from_scans: uploadsFromScans,
    conversion_rate: conversionRate,
    most_active_day: mostActiveDay ? {
      date: mostActiveDay[0],
      scans: mostActiveDay[1]
    } : null,
    unique_users: new Set(scans.map(s => s.ip_address)).size
  };
}
```

---

**End of Detailed Description Section**

*Total: Approximately 4,500 words / 9-10 pages*

**This Detailed Description section is now ready for USPTO provisional patent filing.**

---

**Created:** November 10, 2025  
**For:** Opictuary Provisional Patent Application  
**Innovation:** Dynamic QR Code Memorial Upload System  
**Status:** Detailed Description section complete
